{
  "list": [
    {
      "name": "docs/note/1",
      "title": "笔记",
      "author": "fe_bean",
      "create_time": 1526641781000,
      "update_time": 1526659969000,
      "size": 2653,
      "stat": {
        "dev": 16777218,
        "mode": 33188,
        "nlink": 1,
        "uid": 501,
        "gid": 80,
        "rdev": 0,
        "blksize": 4096,
        "ino": 1720526,
        "size": 2653,
        "blocks": 8,
        "atimeMs": 1531897025000,
        "mtimeMs": 1526659969000,
        "ctimeMs": 1526659969000,
        "birthtimeMs": 1526641781000,
        "atime": "2018-07-18T06:57:05.000Z",
        "mtime": "2018-05-18T16:12:49.000Z",
        "ctime": "2018-05-18T16:12:49.000Z",
        "birthtime": "2018-05-18T11:09:41.000Z"
      },
      "summary": "    关于css各种loader   1.  less loader && sass loader         less loader : 编译less为css        sass loader : 编译scss/sass文件为css 2.  postcss loader : 主要用 autoprefixer， 需要配置conf文件. 3.  css loader : 解析 CSS 文件...",
      "content": "\n## 关于css各种loader\n\n\n1. `less-loader && sass-loader`\n    - `less-loader`: 编译less为css\n    - `sass-loader`: 编译scss/sass文件为css\n2. `postcss-loader`: 主要用 autoprefixer， 需要配置conf文件.\n3. `css-loader`: 解析 CSS 文件后，使用 import 加载，并且返回 CSS 代码 | 使得js能够require css文件，相当于将css模块化，让js去require ex: require('index.css')\n4. `style-loade`r: 页面加载时，让js将css内容以style标签形式加载到页面中去\n\n### postcss-loader配置（两种方式）\n\n1. 根目录下添加 postcss.config.js,\n\n```\nmodule.exports = {\n  plugins: [\n     require('autoprefixer')\n  ]\n}\n```\n\n1. webpack1: 添加配置项:\n\n```\npostcss: function () {\n    return [ require('autoprefixer') ]\n}\n```\n\n2. webpack2: 添加plugin loader的option参数plugins\n\n```\nplugins: function () {\n    return [ require('autoprefixer') ];\n}\n```\n\n>so, 使用顺序是： less(sass)-loader -> postcss-loader -> css-loader -> style-loader.\n>因为loader加载顺序是从右往左，所以webpack配置中：\n```\n\"style-loader!css-loader!postcss-loader!less-loader\"\n```\n>sass同理\n\n\n\n\n## 关于js的loader\n\n### babel-loader: 把es2015（es6）预编译成es5 *\n\n#### presets:\n\n1. `es2015`: es2015转码规则[全部转成es5] | ex:presets[]=es2015\n2. `env`: 根据环境转部分转换成es5，比如浏览器支持的let, const就不预编译 | ex:presets[]=env | <http://www.tuicool.com/articles/YbEfEzz>\n3. `react`: react转码规则 | ex:presets[]=react\n4. `stage-3/2/1/0`: es7四个阶段转码规则 | ex:presets[]=stage-3\n\n#### 各种loader: <https://doc.webpack-china.org/loaders/>\n\n## 关于插件plugins\n\n### webpack自带plugins: <https://doc.webpack-china.org/plugins/>\n\n>CommonsChunkPlugin 将多个入口起点之间共享的公共模块，生成为一些 chunk，并且分离到单独的 bundle 中，例如，1vendor.bundle.js 和 app.bundle.js\n1.  `ExtractTextWebpackPlugin`:    从 bundle 中提取文本（CSS）到分离的文件（app.bundle.css）\n2.  `ComponentWebpackPlugin`:    通过 webpack 使用组件\n3.  `CompressionWebpackPlugin`:     预先准备的资源压缩版本，使用 Content-Encoding 提供访问服务\n4.  `I18nWebpackPlugin`:    为 bundle 增加国际化支持\n5.  `HtmlWebpackPlugin`:    用于简化 HTML 文件（index.html）的创建，提供访问 bundle 的服务。\n6.  `NormalModuleReplacementPlugin`:    替换与正则表达式匹配的资源\n7.  `CleanWebpackPlugin`: 删除指定目录\n\n## resolve 解析器\n\n### resolve.alias | object | 别名配置\n\n<https://doc.webpack-china.org/configuration/resolve/>\n\n## #\n",
      "source": "# 笔记\n- author: fe_bean\n\n## 关于css各种loader\n\n\n1. `less-loader && sass-loader`\n    - `less-loader`: 编译less为css\n    - `sass-loader`: 编译scss/sass文件为css\n2. `postcss-loader`: 主要用 autoprefixer， 需要配置conf文件.\n3. `css-loader`: 解析 CSS 文件后，使用 import 加载，并且返回 CSS 代码 | 使得js能够require css文件，相当于将css模块化，让js去require ex: require('index.css')\n4. `style-loade`r: 页面加载时，让js将css内容以style标签形式加载到页面中去\n\n### postcss-loader配置（两种方式）\n\n1. 根目录下添加 postcss.config.js,\n\n```\nmodule.exports = {\n  plugins: [\n     require('autoprefixer')\n  ]\n}\n```\n\n1. webpack1: 添加配置项:\n\n```\npostcss: function () {\n    return [ require('autoprefixer') ]\n}\n```\n\n2. webpack2: 添加plugin loader的option参数plugins\n\n```\nplugins: function () {\n    return [ require('autoprefixer') ];\n}\n```\n\n>so, 使用顺序是： less(sass)-loader -> postcss-loader -> css-loader -> style-loader.\n>因为loader加载顺序是从右往左，所以webpack配置中：\n```\n\"style-loader!css-loader!postcss-loader!less-loader\"\n```\n>sass同理\n\n\n\n\n## 关于js的loader\n\n### babel-loader: 把es2015（es6）预编译成es5 *\n\n#### presets:\n\n1. `es2015`: es2015转码规则[全部转成es5] | ex:presets[]=es2015\n2. `env`: 根据环境转部分转换成es5，比如浏览器支持的let, const就不预编译 | ex:presets[]=env | <http://www.tuicool.com/articles/YbEfEzz>\n3. `react`: react转码规则 | ex:presets[]=react\n4. `stage-3/2/1/0`: es7四个阶段转码规则 | ex:presets[]=stage-3\n\n#### 各种loader: <https://doc.webpack-china.org/loaders/>\n\n## 关于插件plugins\n\n### webpack自带plugins: <https://doc.webpack-china.org/plugins/>\n\n>CommonsChunkPlugin 将多个入口起点之间共享的公共模块，生成为一些 chunk，并且分离到单独的 bundle 中，例如，1vendor.bundle.js 和 app.bundle.js\n1.  `ExtractTextWebpackPlugin`:    从 bundle 中提取文本（CSS）到分离的文件（app.bundle.css）\n2.  `ComponentWebpackPlugin`:    通过 webpack 使用组件\n3.  `CompressionWebpackPlugin`:     预先准备的资源压缩版本，使用 Content-Encoding 提供访问服务\n4.  `I18nWebpackPlugin`:    为 bundle 增加国际化支持\n5.  `HtmlWebpackPlugin`:    用于简化 HTML 文件（index.html）的创建，提供访问 bundle 的服务。\n6.  `NormalModuleReplacementPlugin`:    替换与正则表达式匹配的资源\n7.  `CleanWebpackPlugin`: 删除指定目录\n\n## resolve 解析器\n\n### resolve.alias | object | 别名配置\n\n<https://doc.webpack-china.org/configuration/resolve/>\n\n## #\n",
      "tag": "",
      "type": ""
    },
    {
      "name": "docs/vue/v_model_self_component",
      "title": "如何在自定义组件中使用v-model",
      "author": "fe_bean",
      "create_time": 1526641781000,
      "update_time": 1526659611000,
      "size": 3395,
      "stat": {
        "dev": 16777218,
        "mode": 33188,
        "nlink": 1,
        "uid": 501,
        "gid": 80,
        "rdev": 0,
        "blksize": 4096,
        "ino": 1720530,
        "size": 3395,
        "blocks": 8,
        "atimeMs": 1531897025000,
        "mtimeMs": 1526659611000,
        "ctimeMs": 1526659611000,
        "birthtimeMs": 1526641781000,
        "atime": "2018-07-18T06:57:05.000Z",
        "mtime": "2018-05-18T16:06:51.000Z",
        "ctime": "2018-05-18T16:06:51.000Z",
        "birthtime": "2018-05-18T11:09:41.000Z"
      },
      "summary": " 文章属于速记，有错误欢迎指出。风格什么的不喜勿喷。      先来一个组件，不用vue model，正常父子通信     html <!   parent   > <template> <div class=\"parent\">     <p>我是父亲, 对儿子说： {{sthGiveChild}}</p>     <Child @returnBack=\"turnBack\" :give=\"sthG...",
      "content": "\n文章属于速记，有错误欢迎指出。风格什么的不喜勿喷。\n\n### 先来一个组件，不用vue-model，正常父子通信\n\n```html\n<!-- parent -->\n<template>\n<div class=\"parent\">\n    <p>我是父亲, 对儿子说： {{sthGiveChild}}</p>\n    <Child @returnBack=\"turnBack\" :give=\"sthGiveChild\"></Child>\n</div>\n</template>\n<script>\nimport Child from './Child.vue';\nexport default {\n    data() {\n        return {\n            sthGiveChild: '给你100块'\n        };\n    },\n    components: {\n        Child\n    },\n    methods: {\n        turnBack(val) {\n            this.sthGiveChild = val;\n        }\n    }\n}\n</script>\n```\n\n```html\n<!-- child -->\n<template>\n<div class=\"child\">\n    <p>我是儿子，父亲对我说： {{give}}</p>\n    <a href=\"javascript:;\" @click=\"returnBackFn\">回应</a>\n</div>\n</template>\n<script>\nexport default {\n    props: {\n        give: String\n    },\n    methods: {\n        returnBackFn() {\n            this.$emit('returnBack', '还你200块');\n        }\n    }\n}\n</script>\n```\n点击回应后，父亲对儿子说的话变成了儿子的回应。儿子收到的信息也变了，实现通信。\n\n### 改用v-model\n```html\n<!-- parent -->\n<template>\n<div class=\"parent\">\n    <p>我是父亲, 对儿子说： {{sthGiveChild}}</p>\n    <Child v-model=\"sthGiveChild\"></Child>\n</div>\n</template>\n<script>\nimport Child from './Child.vue';\nexport default {\n    data() {\n        return {\n            sthGiveChild: '给你100块'\n        };\n    },\n    components: {\n        Child\n    }\n}\n</script>\n```\n\n```html\n<!-- child -->\n<template>\n<div class=\"child\">\n    <p>我是儿子，父亲对我说： {{give}}</p>\n    <a href=\"javascript:;\" @click=\"returnBackFn\">回应</a>\n</div>\n</template>\n<script>\nexport default {\n    props: {\n        give: String\n    },\n    model: {\n        prop: 'give',\n        event: 'returnBack'\n    },\n    methods: {\n        returnBackFn() {\n            this.$emit('returnBack', '还你200块');\n        }\n    }\n}\n</script>\n```\n\n文案虽有不同，但是效果最终是一致的。\n\n### 看看官方自定义组件的v-model\n官方例子[https://vuefe.cn/v2/api/#model](https://vuefe.cn/v2/api/#model)\n\n有这么一句话： ```默认情况下，一个组件上的 v-model 会把 value 用作 prop 且把 input 用作 event。```\n尝试把上边子组件的例子改一下，也是跑的通的\n```html\n<!-- child -->\n<template>\n<div class=\"child\">\n    <p>我是儿子，父亲对我说： {{value}}</p>\n    <a href=\"javascript:;\" @click=\"returnBackFn\">回应</a>\n</div>\n</template>\n<script>\nexport default {\n    props: {\n        value: String\n    },\n    methods: {\n        returnBackFn() {\n            this.$emit('input', '还你200块');\n        }\n    }\n}\n</script>\n```\n\n### 做一下总结：\n- 如果你懒，不想自己去处理事件，那就用默认的 'value' && 'input' 事件去处理，如果用原生事件的，甚至连model属性也可以省去。\n- 如果你想自己的代码比较明确，区分出自定义事件，那么下面的组合才是你的菜。\nprop和event看你自己心情定义，当然要知名见意【尽量避开关键字】\n```\nmodel: {\n    prop: 'someProp', // 注意，是prop，不带s。我在写这个速记的时候，多写了一个s，调试到怀疑人生\n    event: 'someEvent'\n}\nthis.$emit('someProp', [returnValueToParent])\n```\n\n",
      "source": "# 如何在自定义组件中使用v-model\n- author: fe_bean\n\n文章属于速记，有错误欢迎指出。风格什么的不喜勿喷。\n\n### 先来一个组件，不用vue-model，正常父子通信\n\n```html\n<!-- parent -->\n<template>\n<div class=\"parent\">\n    <p>我是父亲, 对儿子说： {{sthGiveChild}}</p>\n    <Child @returnBack=\"turnBack\" :give=\"sthGiveChild\"></Child>\n</div>\n</template>\n<script>\nimport Child from './Child.vue';\nexport default {\n    data() {\n        return {\n            sthGiveChild: '给你100块'\n        };\n    },\n    components: {\n        Child\n    },\n    methods: {\n        turnBack(val) {\n            this.sthGiveChild = val;\n        }\n    }\n}\n</script>\n```\n\n```html\n<!-- child -->\n<template>\n<div class=\"child\">\n    <p>我是儿子，父亲对我说： {{give}}</p>\n    <a href=\"javascript:;\" @click=\"returnBackFn\">回应</a>\n</div>\n</template>\n<script>\nexport default {\n    props: {\n        give: String\n    },\n    methods: {\n        returnBackFn() {\n            this.$emit('returnBack', '还你200块');\n        }\n    }\n}\n</script>\n```\n点击回应后，父亲对儿子说的话变成了儿子的回应。儿子收到的信息也变了，实现通信。\n\n### 改用v-model\n```html\n<!-- parent -->\n<template>\n<div class=\"parent\">\n    <p>我是父亲, 对儿子说： {{sthGiveChild}}</p>\n    <Child v-model=\"sthGiveChild\"></Child>\n</div>\n</template>\n<script>\nimport Child from './Child.vue';\nexport default {\n    data() {\n        return {\n            sthGiveChild: '给你100块'\n        };\n    },\n    components: {\n        Child\n    }\n}\n</script>\n```\n\n```html\n<!-- child -->\n<template>\n<div class=\"child\">\n    <p>我是儿子，父亲对我说： {{give}}</p>\n    <a href=\"javascript:;\" @click=\"returnBackFn\">回应</a>\n</div>\n</template>\n<script>\nexport default {\n    props: {\n        give: String\n    },\n    model: {\n        prop: 'give',\n        event: 'returnBack'\n    },\n    methods: {\n        returnBackFn() {\n            this.$emit('returnBack', '还你200块');\n        }\n    }\n}\n</script>\n```\n\n文案虽有不同，但是效果最终是一致的。\n\n### 看看官方自定义组件的v-model\n官方例子[https://vuefe.cn/v2/api/#model](https://vuefe.cn/v2/api/#model)\n\n有这么一句话： ```默认情况下，一个组件上的 v-model 会把 value 用作 prop 且把 input 用作 event。```\n尝试把上边子组件的例子改一下，也是跑的通的\n```html\n<!-- child -->\n<template>\n<div class=\"child\">\n    <p>我是儿子，父亲对我说： {{value}}</p>\n    <a href=\"javascript:;\" @click=\"returnBackFn\">回应</a>\n</div>\n</template>\n<script>\nexport default {\n    props: {\n        value: String\n    },\n    methods: {\n        returnBackFn() {\n            this.$emit('input', '还你200块');\n        }\n    }\n}\n</script>\n```\n\n### 做一下总结：\n- 如果你懒，不想自己去处理事件，那就用默认的 'value' && 'input' 事件去处理，如果用原生事件的，甚至连model属性也可以省去。\n- 如果你想自己的代码比较明确，区分出自定义事件，那么下面的组合才是你的菜。\nprop和event看你自己心情定义，当然要知名见意【尽量避开关键字】\n```\nmodel: {\n    prop: 'someProp', // 注意，是prop，不带s。我在写这个速记的时候，多写了一个s，调试到怀疑人生\n    event: 'someEvent'\n}\nthis.$emit('someProp', [returnValueToParent])\n```\n\n",
      "tag": "",
      "type": ""
    },
    {
      "name": "docs/webpack/splitChunksPlugin",
      "title": "webpack4 splitChunksPlugin && runtimeChunkPlugin 配置杂记",
      "author": "fe_bean",
      "create_time": 1526641781000,
      "update_time": 1526659606000,
      "size": 4407,
      "stat": {
        "dev": 16777218,
        "mode": 33188,
        "nlink": 1,
        "uid": 501,
        "gid": 80,
        "rdev": 0,
        "blksize": 4096,
        "ino": 1720534,
        "size": 4407,
        "blocks": 16,
        "atimeMs": 1531897025000,
        "mtimeMs": 1526659606000,
        "ctimeMs": 1526659606000,
        "birthtimeMs": 1526641781000,
        "atime": "2018-07-18T06:57:05.000Z",
        "mtime": "2018-05-18T16:06:46.000Z",
        "ctime": "2018-05-18T16:06:46.000Z",
        "birthtime": "2018-05-18T11:09:41.000Z"
      },
      "summary": " > webpack2 还没研究好，就发现升级到4了，你咋这么快~  最近要做项目脚手架，项目构建准备重新做，因为之前写的太烂了...然后发现webpack大版本已经升到4了 又去看了一眼，4.5了 ，这么快的节奏，不适应啊...既然是新的，就用新的来吧，先跳过version3  webpack4 相对于之前的版本，有不少变化，其中包括一些不向下兼容的变化。具体哪些变化这里就不啰嗦了（ 4.0 c...",
      "content": "\n> webpack2 还没研究好，就发现升级到4了，你咋这么快~\n\n最近要做项目脚手架，项目构建准备重新做，因为之前写的太烂了...然后发现webpack大版本已经升到4了(又去看了一眼，4.5了)，这么快的节奏，不适应啊...既然是新的，就用新的来吧，先跳过version3\n\nwebpack4 相对于之前的版本，有不少变化，其中包括一些不向下兼容的变化。具体哪些变化这里就不啰嗦了（[4.0 changelog](https://github.com/webpack/webpack/releases/tag/v4.0.0)， [译文](https://zhuanlan.zhihu.com/p/34028750)），今天主要记录一下 废除 ```commonChunksPlugin``` 之后，怎么使用 ```splitChunksPlugin``` && ```runtimeChunkPlugin```\n> 只记录到自己了解到的部分，不定期更新吧\n\n### splitChunksPlugin\n\n```splitChunksPlugin 默认配置项``` ：\n```json\n{\n    \"chunks\": \"all\",\n    \"minSize\": 0,\n    \"misChunks\": 1,\n    \"maxAsyncRequests\": 1,\n    \"maxInitialRequests\": 1,\n    \"name\": undefined,\n    \"automaticNameDelimiter\": \"~\",\n    \"filename\": undefined,\n    \"cacheGroups\": {}\n}\n```\n稍微来解释下各项配置：\n- **chunks**: all, async, initial 三选一, 插件作用的chunks范围\n- **minSize**： 最小尺寸\n- **misChunks**：最小chunks\n- **maxAsyncRequests**： 最大异步请求chunks\n- **maxInitialRequests**: 最大初始化chunks\n- **name**： split 的 chunks name\n- **automaticNameDelimiter**： 如果不指定name，自动生成name的分隔符（‘runtime~[name]’）\n- **filename**: ''\n- **cacheGroups**: 字面意思缓存组，主要配置在这里\n\n\n```\ncacheGroups配置项：\n```\n\n```json\n[key]: {\n    \"priority\": \"缓存优先级权重\",\n    \"name\": \"split 出来的 chunk 的名字\",\n    \"chunks\": \"应该用范围\",\n    \"enforce\": \"未知\",\n    \"minSize\": \"最小尺寸\",\n    \"minChunks\": \"最小chunks\",\n    \"maxAsyncRequests\": \"\",\n    \"maxInitialRequests\": \"\",\n    \"filename\": \"最后output的文件名\",\n    \"reuseExistingChunk\": \"未知\"\n}\n```\n\n### runtimeChunkPlugin\n```json\n\"runtimeChunk\": {\n    \"name\": \"manifest\"\n}\n```\n\n### 直接上例子了：\n用不着的属性就不配置了，需要关联到 output 和 ExtractTextPlugin 配置\n\n```js\nwebpackConf: {\n    ...,\n    output: {\n        path: path.join(process.cwd(), 'dist'),\n        publicPath,\n        filename: '[name].js',\n        chunkFilename: '[name].js'\n    },\n    optimization: {\n        splitChunks: {\n            chunks: 'initial', // 只对入口文件处理\n            cacheGroups: {\n                vendor: { // split `node_modules`目录下被打包的代码到 `page/vendor.js && .css` 没找到可打包文件的话，则没有。css需要依赖 `ExtractTextPlugin`\n                    test: /node_modules\\//,\n                    name: 'page/vendor',\n                    priority: 10,\n                    enforce: true\n                },\n                commons: { // split `common`和`components`目录下被打包的代码到`page/commons.js && .css`\n                    test: /common\\/|components\\//,\n                    name: 'page/commons',\n                    priority: 10,\n                    enforce: true\n                }\n            }\n        },\n        runtimeChunk: {\n            name: 'page/manifest'\n        }\n    },\n     plugins: [\n        new ExtractTextPlugin({\n            filename: '[name].css',\n            ignoreOrder: true\n        }),\n        ...\n    ]\n    ...\n}\n\n```\n\n```\n以上配置产出大致结构：\n```\n\n如果没有css文件，说明对应目录下没有相关css资源引用，或者未使用ExtractTextPlugin\n```\ndist\n└── page\n    ├── [commons.css]\n    ├── commons.js\n    ├── [manifest.css]\n    ├── manifest.js\n    ├── [vendor.css]\n    ├── vendor.js\n    └── demo // entry 中 配置\n        ├── index.css\n        └── index.js\n```\n\n### 写在最后\n上边的例子是用的 `optimization` 配置项形式，你也可以用 `plugin` 形式，配置参数应该一样的。\n\n之前搜索相关的配置，介绍的文章较少，有一些简单的demo，但总觉得不受用。\n参考了不少文章，然后又大概读了 `webpack` 的 `splitChunksPlugin` 的源码，去了解了下都有哪些参数，看源码挺好\n\n<br>\n\n********************************** done **********************************\n",
      "source": "# webpack4 splitChunksPlugin && runtimeChunkPlugin 配置杂记\n- author: fe_bean\n\n> webpack2 还没研究好，就发现升级到4了，你咋这么快~\n\n最近要做项目脚手架，项目构建准备重新做，因为之前写的太烂了...然后发现webpack大版本已经升到4了(又去看了一眼，4.5了)，这么快的节奏，不适应啊...既然是新的，就用新的来吧，先跳过version3\n\nwebpack4 相对于之前的版本，有不少变化，其中包括一些不向下兼容的变化。具体哪些变化这里就不啰嗦了（[4.0 changelog](https://github.com/webpack/webpack/releases/tag/v4.0.0)， [译文](https://zhuanlan.zhihu.com/p/34028750)），今天主要记录一下 废除 ```commonChunksPlugin``` 之后，怎么使用 ```splitChunksPlugin``` && ```runtimeChunkPlugin```\n> 只记录到自己了解到的部分，不定期更新吧\n\n### splitChunksPlugin\n\n```splitChunksPlugin 默认配置项``` ：\n```json\n{\n    \"chunks\": \"all\",\n    \"minSize\": 0,\n    \"misChunks\": 1,\n    \"maxAsyncRequests\": 1,\n    \"maxInitialRequests\": 1,\n    \"name\": undefined,\n    \"automaticNameDelimiter\": \"~\",\n    \"filename\": undefined,\n    \"cacheGroups\": {}\n}\n```\n稍微来解释下各项配置：\n- **chunks**: all, async, initial 三选一, 插件作用的chunks范围\n- **minSize**： 最小尺寸\n- **misChunks**：最小chunks\n- **maxAsyncRequests**： 最大异步请求chunks\n- **maxInitialRequests**: 最大初始化chunks\n- **name**： split 的 chunks name\n- **automaticNameDelimiter**： 如果不指定name，自动生成name的分隔符（‘runtime~[name]’）\n- **filename**: ''\n- **cacheGroups**: 字面意思缓存组，主要配置在这里\n\n\n```\ncacheGroups配置项：\n```\n\n```json\n[key]: {\n    \"priority\": \"缓存优先级权重\",\n    \"name\": \"split 出来的 chunk 的名字\",\n    \"chunks\": \"应该用范围\",\n    \"enforce\": \"未知\",\n    \"minSize\": \"最小尺寸\",\n    \"minChunks\": \"最小chunks\",\n    \"maxAsyncRequests\": \"\",\n    \"maxInitialRequests\": \"\",\n    \"filename\": \"最后output的文件名\",\n    \"reuseExistingChunk\": \"未知\"\n}\n```\n\n### runtimeChunkPlugin\n```json\n\"runtimeChunk\": {\n    \"name\": \"manifest\"\n}\n```\n\n### 直接上例子了：\n用不着的属性就不配置了，需要关联到 output 和 ExtractTextPlugin 配置\n\n```js\nwebpackConf: {\n    ...,\n    output: {\n        path: path.join(process.cwd(), 'dist'),\n        publicPath,\n        filename: '[name].js',\n        chunkFilename: '[name].js'\n    },\n    optimization: {\n        splitChunks: {\n            chunks: 'initial', // 只对入口文件处理\n            cacheGroups: {\n                vendor: { // split `node_modules`目录下被打包的代码到 `page/vendor.js && .css` 没找到可打包文件的话，则没有。css需要依赖 `ExtractTextPlugin`\n                    test: /node_modules\\//,\n                    name: 'page/vendor',\n                    priority: 10,\n                    enforce: true\n                },\n                commons: { // split `common`和`components`目录下被打包的代码到`page/commons.js && .css`\n                    test: /common\\/|components\\//,\n                    name: 'page/commons',\n                    priority: 10,\n                    enforce: true\n                }\n            }\n        },\n        runtimeChunk: {\n            name: 'page/manifest'\n        }\n    },\n     plugins: [\n        new ExtractTextPlugin({\n            filename: '[name].css',\n            ignoreOrder: true\n        }),\n        ...\n    ]\n    ...\n}\n\n```\n\n```\n以上配置产出大致结构：\n```\n\n如果没有css文件，说明对应目录下没有相关css资源引用，或者未使用ExtractTextPlugin\n```\ndist\n└── page\n    ├── [commons.css]\n    ├── commons.js\n    ├── [manifest.css]\n    ├── manifest.js\n    ├── [vendor.css]\n    ├── vendor.js\n    └── demo // entry 中 配置\n        ├── index.css\n        └── index.js\n```\n\n### 写在最后\n上边的例子是用的 `optimization` 配置项形式，你也可以用 `plugin` 形式，配置参数应该一样的。\n\n之前搜索相关的配置，介绍的文章较少，有一些简单的demo，但总觉得不受用。\n参考了不少文章，然后又大概读了 `webpack` 的 `splitChunksPlugin` 的源码，去了解了下都有哪些参数，看源码挺好\n\n<br>\n\n********************************** done **********************************\n",
      "tag": "",
      "type": ""
    }
  ],
  "count": 3
}